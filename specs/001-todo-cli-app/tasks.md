---
description: "Task list for Todo In-Memory Python Console Application"
---

# Tasks: Todo In-Memory Python Console Application

**Input**: Design documents from `/specs/001-todo-cli-app/`
**Prerequisites**: plan.md (required), spec.md (required for user stories), research.md, data-model.md

**Tests**: No automated tests in Phase I. Manual testing via acceptance scenarios.

**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.

## Constitutional Compliance

**Phase Applicability**: Phase I

### Task-Level Constitutional Requirements

All tasks MUST satisfy:
- [x] **Agentic Implementation (I)**: All tasks implemented by Claude Code only
- [x] **Atomic & Testable (IV)**: Each task is independently testable with explicit acceptance criteria
- [x] **Constitutional Acceptance Criteria**: Every task includes constitutional compliance checks where applicable

### Phase-Specific Task Requirements

**Phase I**: Tasks reflect CLI-only interaction, in-memory storage, no auth, no persistence

### Compliance Verification Per Task

Each task completion MUST verify:
1. Implementation generated by Claude Code (not human-written)
2. Manual tests pass (if applicable to task)
3. Constitutional laws respected (Phase I requirements)
4. Code references to plan.md decisions included
5. No violations of phase-specific requirements

## Format: `[ID] [P?] [Story] Description`

- **[P]**: Can run in parallel (different files, no dependencies)
- **[Story]**: Which user story this task belongs to (e.g., US1, US2, US3, US4, Setup, Foundation)
- Include exact file paths in descriptions

## Path Conventions

- **Single project**: `src/`, at repository root
- All paths shown below use repository root as base

---

## Phase 1: Setup (Shared Infrastructure)

**Purpose**: Project initialization and basic structure

- [x] T001 Create project directory structure (src/, tests/, specs/)
- [x] T002 Initialize pyproject.toml for UV with Python 3.13+ requirement
- [x] T003 [P] Create .gitignore file (exclude .venv/, __pycache__/, *.pyc, .DS_Store, *.egg-info/)
- [x] T004 [P] Create empty src/__init__.py package marker

**Acceptance Criteria (T001-T004)**:
- Directory structure matches plan.md specification
- pyproject.toml valid and specifies Python >= 3.13
- .gitignore excludes all standard Python artifacts
- UV can sync environment: `uv sync` executes without error

---

## Phase 2: Foundational (Blocking Prerequisites)

**Purpose**: Core infrastructure that MUST be complete before ANY user story can be implemented

**‚ö†Ô∏è CRITICAL**: No user story work can begin until this phase is complete

- [x] T005 [P] [Foundation] Implement Todo dataclass in src/todo.py with fields: id (int), title (str), description (str=""), completed (bool=False)
- [x] T006 [Foundation] Implement storage.py with global storage dict and next_id counter
- [x] T007 [Foundation] Implement add_todo() function in storage.py (create todo with auto-generated ID)
- [x] T008 [P] [Foundation] Implement get_todo(todo_id: int) function in storage.py (return Todo or None)
- [x] T009 [P] [Foundation] Implement get_all_todos() function in storage.py (return list of all todos)
- [x] T010 [Foundation] Implement update_todo(todo_id: int, **kwargs) function in storage.py
- [x] T011 [Foundation] Implement delete_todo(todo_id: int) function in storage.py
- [x] T012 [Foundation] Implement mark_complete(todo_id: int, completed: bool) function in storage.py

**Acceptance Criteria (T005-T012)**:
- Todo dataclass has all 4 fields with correct types and defaults
- Storage dict initialized: `todos: dict[int, Todo] = {}`
- ID counter initialized: `next_id: int = 1`
- add_todo() creates todo with unique ID, increments counter
- get_todo() returns Todo if exists, None otherwise
- get_all_todos() returns list of all Todo objects
- update_todo() modifies todo fields, returns True if found
- delete_todo() removes todo, returns True if found
- mark_complete() toggles status, returns True if found
- All storage functions handle missing IDs gracefully

**Checkpoint**: Foundation ready - user story implementation can now begin in parallel

---

## Phase 3: User Story 1 - Add and View Todos (Priority: P1) üéØ MVP

**Goal**: Users can add todos with titles and optional descriptions, then view the complete list

**Independent Test**: Launch app, add 3 todos (one with description, two without), view list, verify all 3 appear with correct IDs and details

### Implementation for User Story 1

- [x] T013 [P] [US1] Implement add_new_todo(title: str, description: str) in src/operations.py with validation (non-empty title)
- [x] T014 [P] [US1] Implement view_all_todos() in src/operations.py (call storage, format result dict)
- [x] T015 [US1] Implement display_todos(todos: list[Todo]) in src/cli.py with formatted table output
- [x] T016 [US1] Implement handle_add_todo() in src/cli.py (prompt for title/description, call operations.add_new_todo())
- [x] T017 [US1] Implement handle_view_todos() in src/cli.py (call operations.view_all_todos(), display results)
- [x] T018 [US1] Implement display_menu() in src/cli.py showing options 1-6
- [x] T019 [US1] Implement get_menu_choice() in src/cli.py with input validation (1-6)
- [x] T020 [US1] Implement run_cli() main loop in src/cli.py (menu display, choice handling, loop until exit)
- [x] T021 [US1] Implement main.py entry point (import cli, call run_cli(), handle Ctrl+C)

**Acceptance Criteria (T013-T021)**:
- add_new_todo() validates title is non-empty, returns {"success": bool, "message": str, "data": Todo}
- view_all_todos() returns {"success": true, "data": list[Todo]}
- display_todos() formats table with ID | Title | Description | Status columns
- display_todos() shows "No todos found" when list is empty
- handle_add_todo() prompts for title (required) and description (optional)
- handle_add_todo() rejects empty titles with error message
- handle_view_todos() displays formatted list or empty message
- display_menu() shows all 6 options with clear labels
- get_menu_choice() validates input is 1-6, prompts again on invalid input
- run_cli() loops until user selects exit (option 6)
- main.py starts application cleanly with `python src/main.py`
- Application handles Ctrl+C gracefully (exits without error)

**Manual Test (US1)**:
1. Run `uv run python src/main.py`
2. Select option 1 (Add Todo)
3. Enter title: "Buy groceries"
4. Enter description: "Milk, eggs, bread"
5. Verify success message with ID
6. Select option 2 (View Todos)
7. Verify todo appears with ID 1, title, description, status=Incomplete
8. Repeat add two more todos (one with description, one without)
9. View list, verify all 3 todos appear
10. Verify IDs are unique (1, 2, 3)

**Checkpoint**: At this point, User Story 1 (MVP) should be fully functional and testable independently

---

## Phase 4: User Story 2 - Mark Todos Complete (Priority: P2)

**Goal**: Users can toggle completion status of todos and see status reflected in list view

**Independent Test**: Add 3 todos, mark one complete, view list to confirm status change, mark another complete, verify both show as complete

### Implementation for User Story 2

- [x] T022 [US2] Implement toggle_todo_status(todo_id: int, complete: bool) in src/operations.py
- [x] T023 [US2] Implement handle_mark_complete() in src/cli.py (prompt for ID and status, call operations)
- [x] T024 [US2] Update display_todos() in src/cli.py to clearly distinguish complete vs incomplete status

**Acceptance Criteria (T022-T024)**:
- toggle_todo_status() validates todo ID exists
- toggle_todo_status() calls storage.mark_complete()
- toggle_todo_status() returns {"success": bool, "message": str}
- handle_mark_complete() prompts for todo ID
- handle_mark_complete() prompts "Is it complete? (y/n)"
- handle_mark_complete() displays clear success/error messages
- display_todos() shows status as "Complete" or "Incomplete" (or [‚úì]/[ ])
- Status changes are immediately reflected in next view

**Manual Test (US2)**:
1. Run application
2. Add 3 todos
3. View list (all should be Incomplete)
4. Select option 4 (Mark Complete/Incomplete)
5. Enter todo ID: 1
6. Enter: y (mark complete)
7. View list, verify todo 1 shows Complete
8. Mark todo 2 complete
9. View list, verify todos 1 and 2 show Complete
10. Mark todo 1 incomplete (toggle back)
11. View list, verify todo 1 now shows Incomplete
12. Try marking invalid ID (999), verify error message

**Checkpoint**: At this point, User Stories 1 AND 2 should both work independently

---

## Phase 5: User Story 3 - Update Todo Details (Priority: P3)

**Goal**: Users can modify todo titles and descriptions

**Independent Test**: Add todo "Buy mlk", update title to "Buy milk", view to confirm change, update description to "2% milk, gallon", verify both changes appear

### Implementation for User Story 3

- [x] T025 [US3] Implement update_todo_details(todo_id: int, title: str | None, description: str | None) in src/operations.py
- [x] T026 [US3] Implement handle_update_todo() in src/cli.py (prompt for ID, ask which fields to update, call operations)

**Acceptance Criteria (T025-T026)**:
- update_todo_details() validates todo ID exists
- update_todo_details() validates new title is non-empty if provided
- update_todo_details() accepts None for fields that shouldn't change
- update_todo_details() calls storage.update_todo()
- update_todo_details() returns {"success": bool, "message": str}
- handle_update_todo() prompts for todo ID
- handle_update_todo() asks "Update title? (y/n)"
- handle_update_todo() asks "Update description? (y/n)"
- handle_update_todo() only prompts for new values if user answers yes
- handle_update_todo() displays success/error messages
- Changes persist in memory for current session

**Manual Test (US3)**:
1. Run application
2. Add todo "Buy mlk" (typo intentional)
3. View list, note ID
4. Select option 3 (Update Todo)
5. Enter todo ID
6. Update title? y
7. Enter: "Buy milk"
8. Update description? y
9. Enter: "2% milk, gallon"
10. View list, verify both changes appear
11. Try updating invalid ID (999), verify error message
12. Try updating with empty title, verify error message

**Checkpoint**: All user stories 1, 2, and 3 should now be independently functional

---

## Phase 6: User Story 4 - Delete Todos (Priority: P4)

**Goal**: Users can remove todos from the list

**Independent Test**: Add 4 todos, delete todo ID 2, view list to confirm only 3 remain, attempt to delete ID 2 again to verify error handling, delete all remaining todos

### Implementation for User Story 4

- [x] T027 [US4] Implement remove_todo(todo_id: int) in src/operations.py
- [x] T028 [US4] Implement handle_delete_todo() in src/cli.py (prompt for ID, call operations, display result)

**Acceptance Criteria (T027-T028)**:
- remove_todo() validates todo ID exists
- remove_todo() calls storage.delete_todo()
- remove_todo() returns {"success": bool, "message": str}
- handle_delete_todo() prompts for todo ID
- handle_delete_todo() displays clear success/error messages
- Deleted todos no longer appear in view
- Deleted IDs return "not found" error if accessed again

**Manual Test (US4)**:
1. Run application
2. Add 4 todos (IDs: 1, 2, 3, 4)
3. View list, verify all 4 appear
4. Select option 5 (Delete Todo)
5. Enter todo ID: 2
6. View list, verify only 3 todos remain (1, 3, 4)
7. Try deleting ID 2 again, verify error "Todo ID not found"
8. Delete todos 1, 3, 4
9. View list, verify "No todos found" message
10. Try deleting from empty list, verify error message

**Checkpoint**: All user stories should now be independently functional

---

## Phase 7: Polish & Documentation

**Purpose**: Finalize documentation and ensure production-ready quality

- [x] T029 [P] Create README.md with setup instructions, usage overview, and feature list
- [x] T030 [P] Verify CLAUDE.md exists and contains agent operating rules
- [x] T031 [P] Add error handling for non-integer ID inputs in cli.py (try-except around int())
- [x] T032 [P] Add visual separators and formatting to menu display
- [x] T033 Run complete manual test suite covering all 4 user stories
- [x] T034 Verify application can handle 100+ todos (add 100, view list, update one, delete one)
- [x] T035 Test 20+ consecutive operations in single session without errors

**Acceptance Criteria (T029-T035)**:
- README.md includes: Python 3.13+ requirement, UV installation, run instructions, feature list
- CLAUDE.md exists with appropriate content
- Non-integer ID input shows "Please enter a valid number" instead of crashing
- Menu display uses visual separators (==== lines)
- All acceptance scenarios from spec.md pass
- Application handles 100 todos without slowdown
- Application supports 20+ operations without crashes or errors

---

## Dependencies & Execution Order

### Phase Dependencies

- **Setup (Phase 1)**: No dependencies - can start immediately
- **Foundational (Phase 2)**: Depends on Setup completion - BLOCKS all user stories
- **User Stories (Phase 3-6)**: All depend on Foundational phase completion
  - User Story 1 (P1): MUST complete first (MVP, other stories depend on add/view)
  - User Story 2 (P2): Can start after US1 complete (needs display_todos from US1)
  - User Story 3 (P3): Can start after US1 complete (independent of US2)
  - User Story 4 (P4): Can start after US1 complete (independent of US2/US3)
- **Polish (Phase 7)**: Depends on all user stories being complete

### User Story Dependencies

- **User Story 1 (P1)**: Depends on Foundation - No dependencies on other stories - MUST COMPLETE FIRST
- **User Story 2 (P2)**: Depends on US1 (needs display_todos) - Independent of US3/US4
- **User Story 3 (P3)**: Depends on US1 (needs operations module structure) - Independent of US2/US4
- **User Story 4 (P4)**: Depends on US1 (needs operations module structure) - Independent of US2/US3

### Within Each Phase

**Setup (Phase 1)**:
- All tasks marked [P] can run in parallel
- T001 must complete before T002-T004

**Foundational (Phase 2)**:
- T005 must complete first (Todo dataclass needed by storage)
- T006 must complete second (storage dict/counter needed by functions)
- T007-T012 depend on T005, T006
- T008, T009, T010, T011, T012 can run in parallel after T007

**User Story 1 (MVP)**:
- T013, T014 can run in parallel (both operate on storage)
- T015 depends on T014 (needs data format)
- T016, T017 depend on T013, T014, T015
- T018, T019 can run in parallel (independent UI functions)
- T020 depends on T016, T017, T018, T019 (main loop uses all)
- T021 depends on T020 (entry point calls main loop)

**User Story 2**:
- T022 can start independently
- T023 depends on T022
- T024 modifies existing T015 output

**User Story 3**:
- T025 can start independently
- T026 depends on T025

**User Story 4**:
- T027 can start independently
- T028 depends on T027

**Polish**:
- T029, T030, T031, T032 can run in parallel
- T033, T034, T035 run sequentially after T029-T032

### Parallel Opportunities

- **Setup**: T003, T004 parallel after T001-T002
- **Foundation**: T008, T009 parallel after T007
- **User Story 1**: T013 + T014 parallel, T018 + T019 parallel
- **User Stories 2-4**: All three can be worked in parallel after US1 complete
- **Polish**: T029, T030, T031, T032 all parallel

---

## Implementation Strategy

### Sequential MVP Approach (Recommended)

1. Complete Phase 1: Setup (T001-T004)
2. Complete Phase 2: Foundation (T005-T012)
3. Complete Phase 3: User Story 1 (T013-T021) - **STOP and VALIDATE**
4. Test User Story 1 independently (can add, can view, menu works)
5. Complete Phase 4: User Story 2 (T022-T024)
6. Complete Phase 5: User Story 3 (T025-T026)
7. Complete Phase 6: User Story 4 (T027-T028)
8. Complete Phase 7: Polish (T029-T035)

### Incremental Delivery

After each user story:
1. **After US1**: MVP functional (add + view)
2. **After US2**: Can track completion status
3. **After US3**: Can fix mistakes and add detail
4. **After US4**: Full CRUD operations complete

---

## Task Summary

| Phase | Task Range | Count | Can Start After |
|-------|-----------|-------|-----------------|
| Setup | T001-T004 | 4 | Immediately |
| Foundation | T005-T012 | 8 | Setup complete |
| User Story 1 (MVP) | T013-T021 | 9 | Foundation complete |
| User Story 2 | T022-T024 | 3 | US1 complete |
| User Story 3 | T025-T026 | 2 | US1 complete |
| User Story 4 | T027-T028 | 2 | US1 complete |
| Polish | T029-T035 | 7 | All US complete |
| **TOTAL** | **T001-T035** | **35** | N/A |

---

## Constitutional Compliance Checklist

Before marking Phase complete, verify:

- [ ] All code generated by Claude Code (no human implementation)
- [ ] All tasks have explicit acceptance criteria
- [ ] Phase I requirements met: CLI-only, in-memory, no persistence, no auth
- [ ] No external dependencies (standard library only)
- [ ] No databases, files, web, auth, AI, containers, cloud
- [ ] Plan.md decisions followed
- [ ] Spec.md requirements satisfied

---

## Notes

- No automated tests (manual testing via acceptance scenarios)
- All operations must handle errors gracefully (no crashes)
- IDs auto-increment and never reuse (even after deletion)
- Data lost on application exit (acceptable for Phase I)
- Each user story independently testable at completion
- MVP (US1) must work before starting other stories
- Stop after each user story to validate independently

---

**Tasks Generation Complete** ‚úÖ
**Total Tasks**: 35
**Ready for**: Implementation (`/sp.implement`)

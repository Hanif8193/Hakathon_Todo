# Implementation Plan: Todo In-Memory Python Console Application

**Branch**: `001-todo-cli-app` | **Date**: 2026-01-13 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-todo-cli-app/spec.md`

**Note**: This plan translates the Phase I specification into a structured, executable implementation strategy for Claude Code.

## Summary

Build a command-line todo application in Python that stores tasks in memory. The application provides five core operations (add, view, update, mark complete/incomplete, delete) through a menu-driven interface. All code will be generated by Claude Code following spec-driven development principles. No persistence, authentication, or external dependencies are permitted in Phase I.

**Technical Approach**: Modular Python architecture with separated concerns (data model, storage, business logic, CLI) using only Python standard library and UV for dependency management.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: None (Python standard library only)
**Storage**: In-memory Python dictionaryls
**Testing**: Manual testing via acceptance scenarios (no automated tests required)
**Target Platform**: Linux, macOS, Windows (WSL recommended)
**Project Type**: Single Python console application
**Performance Goals**: Handle 100+ todos, sub-second response times for all operations
**Constraints**: No persistence, no external libraries, CLI-only interface
**Scale/Scope**: Small (single-file entry point, 4-5 supporting modules, ~500 LOC total)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Phase Applicability**: Phase I

### Immutable Global Laws (ALL phases)
- [x] **Agentic Implementation Law (I)**: No human-written implementation code
- [x] **Spec-Driven Development Law (II)**: Approved spec exists and drives implementation (spec.md created)
- [x] **Plan-Before-Build Law (III)**: This plan documents design decisions and rationale
- [x] **Task Decomposition Law (IV)**: Tasks will be atomic and independently testable (tasks.md to follow)
- [x] **Iterative Review Law (V)**: Review checkpoints defined (after research, after design, before implementation)
- [x] **Document Hierarchy Law (VI)**: Plan acknowledges Constitution > Specs > CLAUDE.md > Code

### Phase-Specific Requirements

**Phase I (CLI Foundation)**:
- [x] CLI-only user interaction (menu-driven interface)
- [x] In-memory data storage only (Python dictionary)
- [x] No external service dependencies (standard library only)
- [x] No authentication/authorization (single-user, no user concept)

**Phase II (Web Application)** - NOT applicable to Phase I

**Phase III (AI-Powered Agents)** - NOT applicable to Phase I

**Phase IV (Container Orchestration)** - NOT applicable to Phase I

**Phase V (Cloud-Native Architecture)** - NOT applicable to Phase I

### Security & Identity Laws (Phase II+)
- [ ] N/A - Phase I has no authentication
- [ ] N/A - Phase I is single-user
- [ ] N/A - Phase I has no secrets to manage

### AI & Agent Governance (Phase III+)
- [ ] N/A - Phase I has no AI agents
- [ ] N/A - Phase I has no MCP tools
- [ ] N/A - Phase I has no conversation state

### Infrastructure Neutrality (Phase IV+)
- [ ] N/A - Phase I has no containers
- [ ] N/A - Phase I has no cloud dependencies
- [ ] N/A - Phase I runs directly on local Python

## Project Structure

### Documentation (this feature)

```text
specs/001-todo-cli-app/
├── spec.md              # Feature specification
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (technology decisions)
├── data-model.md        # Phase 1 output (entity definitions)
├── quickstart.md        # Phase 1 output (user guide)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
todo/
├── src/
│   ├── __init__.py        # Package marker (empty)
│   ├── todo.py            # Todo dataclass entity
│   ├── storage.py         # In-memory storage operations
│   ├── operations.py      # Business logic (add, update, delete, etc.)
│   ├── cli.py             # Command-line interface and menu
│   └── main.py            # Application entry point
├── tests/                 # (Empty for Phase I - no automated tests)
├── .venv/                 # Virtual environment (created by UV)
├── pyproject.toml         # UV project configuration
├── README.md              # Project documentation
├── CLAUDE.md              # Claude Code operating rules
└── .gitignore             # Git ignore file
```

**Structure Decision**: Single project structure selected because this is a standalone CLI application with no frontend/backend separation. All code lives under `src/` with clear module separation for testability and future extensibility.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No constitutional violations detected. All requirements align with Phase I governance.

---

## Phase 0: Research & Technology Decisions

**Status**: ✅ Complete

**Output**: `research.md`

**Key Decisions Made**:

1. **Python Version**: Python 3.13+ (spec requirement)
2. **Dependency Management**: UV (spec requirement)
3. **Data Model**: Python dataclass with 4 fields (id, title, description, completed)
4. **Storage**: Dictionary with integer keys for O(1) lookup
5. **CLI Pattern**: Menu-driven loop with numbered options
6. **Error Handling**: Try-except with custom error messages
7. **Code Organization**: 5 modules (todo, storage, operations, cli, main)
8. **Display Format**: Simple text table with visual separators
9. **Testing**: Manual testing via acceptance scenarios (no automated tests)
10. **Dependencies**: None (standard library only)

**Alternatives Considered**:
- **Storage**: List vs Dictionary → Dictionary chosen for O(1) ID lookups
- **CLI Framework**: Click/Typer vs Native → Native chosen (no external deps allowed)
- **Data Model**: Dict vs Dataclass → Dataclass chosen for type safety and clarity

**Rationale**: All decisions traceable to spec requirements and constitutional constraints. No external dependencies, CLI-only, in-memory storage.

---

## Phase 1: Design & Contracts

**Status**: ✅ Complete

**Outputs**:
- `data-model.md` - Entity definitions, storage model, validation rules
- `quickstart.md` - User guide and usage examples
- No contracts (CLI application has no API endpoints)

### Data Model Summary

**Entity**: Todo
- `id`: int (unique, auto-generated, starts at 1)
- `title`: str (required, non-empty)
- `description`: str (optional, default="")
- `completed`: bool (default=False)

**Storage**: `dict[int, Todo]` with auto-incrementing ID counter

**State Transitions**: Incomplete ↔ Complete (bidirectional)

**Validation**:
- Title: Must be non-empty
- ID: Must exist in storage
- All operations: Graceful error handling

### API Contracts

**N/A** - CLI application has no API endpoints. User interaction is via text menu only.

### Agent Context

**N/A** - Phase I does not use agent-specific context files. This is relevant for Phase III+ (AI agents).

---

## Phase 2: Implementation Strategy

This section outlines the implementation approach that will be translated into atomic tasks in `tasks.md` (via `/sp.tasks` command).

### Implementation Modules

#### Module 1: Todo Entity (`src/todo.py`)

**Purpose**: Define the Todo dataclass

**Responsibilities**:
- Todo dataclass with 4 fields
- Type hints for all fields
- Default values (description="", completed=False)

**Dependencies**: Python dataclasses module

**Complexity**: Low (single dataclass definition)

---

#### Module 2: Storage Layer (`src/storage.py`)

**Purpose**: Manage in-memory todo storage

**Responsibilities**:
- Global storage dictionary
- Global ID counter
- Storage initialization
- CRUD operations (create, read, update, delete)
- ID generation and uniqueness

**Key Functions**:
- `add_todo(title: str, description: str = "") -> Todo`
- `get_todo(todo_id: int) -> Todo | None`
- `get_all_todos() -> list[Todo]`
- `update_todo(todo_id: int, **kwargs) -> bool`
- `delete_todo(todo_id: int) -> bool`
- `mark_complete(todo_id: int, completed: bool) -> bool`

**Dependencies**: todo.py

**Complexity**: Medium (ID management, dictionary operations)

---

#### Module 3: Business Logic (`src/operations.py`)

**Purpose**: Implement todo operations with validation

**Responsibilities**:
- Validate user inputs
- Call storage layer functions
- Return success/error messages
- Handle edge cases

**Key Functions**:
- `add_new_todo(title: str, description: str = "") -> dict`
- `view_all_todos() -> dict`
- `update_todo_details(todo_id: int, title: str | None, description: str | None) -> dict`
- `toggle_todo_status(todo_id: int, complete: bool) -> dict`
- `remove_todo(todo_id: int) -> dict`

**Return Format**: `{"success": bool, "message": str, "data": any}`

**Dependencies**: storage.py

**Complexity**: Medium (validation, error handling)

---

#### Module 4: CLI Interface (`src/cli.py`)

**Purpose**: Provide command-line user interface

**Responsibilities**:
- Display menu
- Get user input
- Call operations
- Display results
- Loop until exit

**Key Functions**:
- `display_menu()`
- `display_todos(todos: list[Todo])`
- `get_menu_choice() -> int`
- `handle_add_todo()`
- `handle_view_todos()`
- `handle_update_todo()`
- `handle_mark_complete()`
- `handle_delete_todo()`
- `run_cli()` (main loop)

**Dependencies**: operations.py

**Complexity**: Medium-High (user interaction, formatting)

---

#### Module 5: Application Entry Point (`src/main.py`)

**Purpose**: Application entry point

**Responsibilities**:
- Import cli module
- Call `run_cli()`
- Handle Ctrl+C gracefully

**Complexity**: Low (minimal logic)

---

### Module Dependency Graph

```
main.py
  └── cli.py
       └── operations.py
            └── storage.py
                 └── todo.py
```

**Execution Flow**:
1. User runs `main.py`
2. `main.py` calls `cli.run_cli()`
3. CLI displays menu and gets choice
4. CLI calls appropriate operation function
5. Operation validates and calls storage function
6. Storage manipulates todo dictionary
7. Result flows back up to CLI
8. CLI displays result to user
9. Loop repeats until exit

---

### Implementation Sequence

**Sequence Rationale**: Bottom-up implementation (data model → storage → logic → UI) ensures each layer can be tested as it's built.

1. **Setup Phase** (Foundation):
   - Create project structure
   - Configure pyproject.toml for UV
   - Create .gitignore
   - Create empty __init__.py

2. **Data Layer** (Core Entities):
   - Implement todo.py (dataclass)
   - Implement storage.py (dictionary + CRUD)

3. **Logic Layer** (Business Rules):
   - Implement operations.py (validation + storage calls)

4. **Presentation Layer** (User Interface):
   - Implement cli.py (menu + display + input handling)
   - Implement main.py (entry point)

5. **Documentation**:
   - Update README.md with setup instructions
   - Ensure CLAUDE.md exists with agent rules

---

### Error Handling Strategy

**Validation Points**:
1. **User Input Validation** (CLI layer):
   - Menu choice: Must be 1-6
   - Todo ID: Must be valid integer
   - Title: Must not be empty

2. **Business Logic Validation** (Operations layer):
   - Title: Strip whitespace, check non-empty
   - ID: Check existence in storage
   - Return structured error messages

3. **Storage Validation** (Storage layer):
   - ID uniqueness (enforced by auto-increment)
   - Safe dictionary access (use .get())

**Error Messages**:
- "Title cannot be empty"
- "Todo ID not found"
- "Please enter a valid number"
- "Invalid option, please try again"

**Error Handling Principles**:
- Never crash the application
- Always return to menu after error
- Provide clear, actionable feedback
- No exception propagation to user

---

### User Interaction Flow

**Main Menu Loop**:
```
1. Display menu
2. Get user choice (1-6)
3. Execute corresponding handler
4. Display result
5. Return to step 1 (unless choice = 6)
```

**Add Todo Flow**:
```
1. Prompt for title
2. Validate title (non-empty)
3. Prompt for description (optional)
4. Call operations.add_new_todo()
5. Display success message with ID
```

**View Todos Flow**:
```
1. Call operations.view_all_todos()
2. If empty: display "No todos found"
3. Else: display formatted table
4. Show total count
```

**Update Todo Flow**:
```
1. Prompt for todo ID
2. Validate ID exists
3. Prompt for new title (y/n)
4. If yes: get new title
5. Prompt for new description (y/n)
6. If yes: get new description
7. Call operations.update_todo_details()
8. Display success message
```

**Mark Complete Flow**:
```
1. Prompt for todo ID
2. Validate ID exists
3. Prompt for complete status (y/n)
4. Call operations.toggle_todo_status()
5. Display success message
```

**Delete Todo Flow**:
```
1. Prompt for todo ID
2. Validate ID exists
3. Call operations.remove_todo()
4. Display success message
```

---

### Display Formatting

**Menu Display**:
```
================================================================================
                          TODO CLI APPLICATION
================================================================================

1. Add Todo
2. View Todos
3. Update Todo
4. Mark Complete/Incomplete
5. Delete Todo
6. Exit

Select an option (1-6):
```

**Todos List Display**:
```
================================================================================
                              TODO LIST
================================================================================
ID | Title                          | Description         | Status
--------------------------------------------------------------------------------
1  | Buy groceries                  | Milk, eggs          | Incomplete
2  | Call dentist                   |                     | Complete
================================================================================
Total: 2 todos
```

**Success Messages**:
- "✓ Todo added successfully! (ID: {id})"
- "✓ Todo {id} updated successfully!"
- "✓ Todo {id} marked as complete!"
- "✓ Todo {id} deleted successfully!"

**Error Messages**:
- "✗ Error: Todo ID not found"
- "✗ Error: Title cannot be empty"
- "✗ Error: Please enter a valid number"

---

### Testing Strategy

**Manual Testing**: Follow acceptance scenarios from spec.md

**User Story 1 Test** (Add and View):
1. Launch app
2. Add 3 todos (one with description, two without)
3. View list
4. Verify all 3 appear with correct IDs and details

**User Story 2 Test** (Mark Complete):
1. Add 3 todos
2. Mark first todo complete
3. View list, verify status changed
4. Mark second todo complete
5. View list, verify both marked

**User Story 3 Test** (Update):
1. Add todo with title "Buy mlk"
2. Update title to "Buy milk"
3. View list, verify change
4. Update description
5. View list, verify change

**User Story 4 Test** (Delete):
1. Add 4 todos
2. Delete todo ID 2
3. View list, verify only 3 remain
4. Try deleting ID 2 again, verify error

**Edge Case Tests**:
- Empty title: Should reject
- Invalid ID: Should show error
- Non-integer ID: Should show error
- Invalid menu choice: Should prompt again
- 100+ todos: Should handle without slowdown

---

### Performance Considerations

**Expected Performance**:
- Add todo: < 1ms (dictionary insert)
- View todos: < 10ms for 100 todos (list iteration)
- Update todo: < 1ms (dictionary lookup + update)
- Delete todo: < 1ms (dictionary deletion)
- Mark complete: < 1ms (dictionary lookup + update)

**Scalability**:
- Target: 100 todos (SC-007)
- Tested up to: 100 todos
- Practical limit: Thousands (memory permitting)

**No Optimizations Needed**: Python dictionary and standard operations are sufficient for Phase I requirements.

---

### Configuration

**pyproject.toml** (UV configuration):
```toml
[project]
name = "todo-cli"
version = "0.1.0"
description = "Phase I Todo CLI Application"
requires-python = ">=3.13"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

**.gitignore**:
```
.venv/
__pycache__/
*.pyc
.DS_Store
*.egg-info/
```

---

## Risks & Mitigations

### Risk 1: User Force-Quits Application
**Impact**: Data lost (all todos in memory)
**Likelihood**: High
**Mitigation**: Acceptable per Phase I design (AC-004). Document in README and quickstart.
**Phase II Resolution**: Add database persistence

### Risk 2: Extremely Long Titles/Descriptions
**Impact**: Display formatting issues
**Likelihood**: Low
**Mitigation**: Truncate display (full data stored). No hard limits enforced.
**Workaround**: User can view full text with dedicated "view detail" command (not in Phase I scope)

### Risk 3: Non-Integer Input for ID
**Impact**: Application crash if not handled
**Likelihood**: Medium
**Mitigation**: Try-except around int() conversion, display error message
**Implementation**: CLI validation before calling operations

### Risk 4: Empty Title Submitted
**Impact**: Invalid todo created
**Likelihood**: Medium
**Mitigation**: Validate title is non-empty (after strip) in operations layer
**Implementation**: Reject and prompt again

---

## Dependencies

**External Dependencies**: None

**Standard Library Modules**:
- `dataclasses`: Todo entity definition
- `typing`: Type hints (dict, list, Optional)
- `sys`: Exit handling

**Development Dependencies**:
- UV: Dependency and environment management (not imported in code)

---

## Acceptance Criteria

Implementation is complete when:

1. ✅ All 5 modules exist and are implemented (todo.py, storage.py, operations.py, cli.py, main.py)
2. ✅ Application starts successfully with `uv run python src/main.py`
3. ✅ All 14 functional requirements (FR-001 to FR-014) are satisfied
4. ✅ All 4 user stories pass acceptance scenarios
5. ✅ All edge cases handled gracefully
6. ✅ All 8 success criteria (SC-001 to SC-008) met
7. ✅ No external dependencies (only standard library)
8. ✅ No human-written code (all generated by Claude Code)
9. ✅ README.md and CLAUDE.md documentation complete
10. ✅ Manual testing confirms all operations work

---

## Next Steps

1. **Review & Approve Plan**: Human review of this plan document
2. **Execute `/sp.tasks`**: Generate atomic task breakdown (tasks.md)
3. **Review & Approve Tasks**: Human review of task list
4. **Execute `/sp.implement`**: Claude Code generates all implementation code
5. **Manual Testing**: Execute acceptance scenarios
6. **Documentation**: Verify README.md and quickstart.md accuracy
7. **Phase I Complete**: All requirements satisfied

---

## References

- **Feature Specification**: [spec.md](./spec.md)
- **Constitution**: `/.specify/memory/constitution.md`
- **Research Document**: [research.md](./research.md)
- **Data Model**: [data-model.md](./data-model.md)
- **Quickstart Guide**: [quickstart.md](./quickstart.md)

---

**Implementation Plan Status**: ✅ Complete
**Constitutional Compliance**: ✅ Verified
**Ready for**: Task Generation (`/sp.tasks`)

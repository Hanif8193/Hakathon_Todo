# Implementation Plan: Todo Full-Stack Web Application

**Branch**: `002-todo-fullstack-web` | **Date**: 2026-01-14 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-todo-fullstack-web/spec.md`

## Summary

Transform the Phase I CLI Todo application into a modern multi-user web application with persistent storage, authentication, and responsive UI. The system will provide RESTful APIs for task management (CRUD operations), JWT-based authentication for user isolation, and a Next.js frontend with Tailwind CSS for responsive design. Backend uses FastAPI with SQLModel ORM connected to Neon PostgreSQL for data persistence.

## Technical Context

**Language/Version**: Python 3.11+ (backend), Node.js 18+ (frontend)
**Primary Dependencies**: FastAPI, SQLModel, asyncpg, Next.js 16+, Better Auth, Tailwind CSS
**Storage**: Neon Serverless PostgreSQL with SQLModel ORM
**Testing**: Manual testing for Phase II (pytest/Playwright deferred to Phase III)
**Target Platform**: WSL 2 (Ubuntu 22.04) development environment, Linux server deployment
**Project Type**: Web application (frontend + backend)
**Performance Goals**: <2s task operations, <10s authentication, supports 100 tasks without degradation
**Constraints**: <200ms p95 API latency, 10+ concurrent users, responsive 320px-1920px
**Scale/Scope**: Multi-user web app, 6 user stories, 36 functional requirements, RESTful API

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Phase Applicability**: Phase II (Web Application)

### Immutable Global Laws (ALL phases)
- [x] **Agentic Implementation Law (I)**: All implementation code generated by Claude Code only
- [x] **Spec-Driven Development Law (II)**: Approved spec exists at `specs/002-todo-fullstack-web/spec.md`
- [x] **Plan-Before-Build Law (III)**: This plan documents design decisions, alternatives, rationale
- [x] **Task Decomposition Law (IV)**: Tasks will be atomic, independently testable (generated via /sp.tasks)
- [x] **Iterative Review Law (V)**: Review checkpoints defined at spec, plan, tasks, implementation phases
- [x] **Document Hierarchy Law (VI)**: Constitution > Spec > CLAUDE.md > Code hierarchy acknowledged

### Phase-Specific Requirements

**Phase I (CLI Foundation)**: Not applicable - Phase II implementation

**Phase II (Web Application)** - APPLICABLE:
- [x] **User identity from authentication system**: Better Auth with JWT provides user_id claim
- [x] **Persistent database defined**: Neon PostgreSQL with SQLModel ORM (see data-model.md)
- [x] **RESTful API conventions**: All endpoints follow REST principles (see contracts/)
- [x] **User data isolation strategy**: JWT user_id extraction scopes all database queries
- [x] **Phase I business logic preserved**: Task CRUD concepts retained, architecture evolved

**Phase III (AI-Powered Agents)**: Not applicable - Phase II implementation

**Phase IV (Container Orchestration)**: Not applicable - Phase II implementation

**Phase V (Cloud-Native Architecture)**: Not applicable - Phase II implementation

### Security & Identity Laws (Phase II+)
- [x] **No hardcoded users, passwords, or API keys**: All secrets in environment variables (.env)
- [x] **Identity provider configurable**: Better Auth configured via BETTER_AUTH_SECRET env var
- [x] **Stateless authentication preferred (JWT)**: JWT tokens with 24-hour expiration
- [x] **User data isolation at query level**: All task queries filtered by authenticated user_id
- [x] **Secrets externalized**: DATABASE_URL, BETTER_AUTH_SECRET, NEXT_PUBLIC_API_URL in .env

### AI & Agent Governance (Phase III+)
Not applicable - Phase II does not include AI agents

### Infrastructure Neutrality (Phase IV+)
Not applicable - Phase II does not include containerization or cloud deployment

## Project Structure

### Documentation (this feature)

```text
specs/002-todo-fullstack-web/
├── spec.md              # Feature requirements and acceptance criteria
├── plan.md              # This file - implementation plan
├── research.md          # Phase 0 research findings (completed)
├── data-model.md        # Phase 1 data model specification (to be created)
├── quickstart.md        # Phase 1 local development guide (to be created)
├── contracts/           # Phase 1 API contract specifications (to be created)
│   ├── auth-api.yaml   # Authentication endpoints (OpenAPI)
│   └── tasks-api.yaml  # Task CRUD endpoints (OpenAPI)
├── checklists/          # Feature-specific testing checklists
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
# Web application structure (frontend + backend)

backend/
├── main.py              # FastAPI application entry point, CORS, routers
├── models.py            # SQLModel database models (User, Task)
├── schemas.py           # Pydantic request/response schemas
├── auth.py              # JWT token generation, validation, password hashing
├── database.py          # Async database engine, session management
├── dependencies.py      # Dependency injection (get_session, get_current_user)
└── routers/
    ├── auth.py          # POST /api/auth/signup, /api/auth/login
    └── tasks.py         # Task CRUD endpoints (GET/POST/PUT/PATCH/DELETE /api/tasks)

frontend/
├── src/
│   ├── app/
│   │   ├── (auth)/          # Auth route group (public)
│   │   │   ├── login/       # Login page
│   │   │   └── signup/      # Signup page
│   │   ├── dashboard/       # Protected route - task list
│   │   │   └── page.tsx
│   │   ├── layout.tsx       # Root layout with auth provider
│   │   └── middleware.ts    # Auth middleware for route protection
│   ├── components/
│   │   ├── TaskCard.tsx     # Individual task display component
│   │   ├── TaskForm.tsx     # Create/edit task form
│   │   └── TaskList.tsx     # Task list container
│   └── lib/
│       ├── api.ts           # API client with JWT token attachment
│       └── auth.ts          # Better Auth configuration
├── public/                  # Static assets
├── tailwind.config.js       # Tailwind CSS configuration
├── next.config.js           # Next.js configuration
└── package.json             # Frontend dependencies

.env                         # Environment variables (not committed)
.env.example                 # Example environment variables template
pyproject.toml              # Python backend dependencies (UV)
README.md                   # Project setup and run instructions
```

**Structure Decision**: Web application structure chosen because spec explicitly requires frontend (Next.js) and backend (FastAPI) separation. This enables independent scaling, technology-specific optimizations, and clear separation of concerns between client-side UI and server-side business logic. Aligns with Phase II Web Application requirements.

## Complexity Tracking

No constitutional violations present. All Phase II requirements satisfied without exceptions.

## Design Decisions

### 1. Authentication Architecture

**Decision**: JWT-based stateless authentication with Better Auth library

**Rationale**:
- **Stateless**: No server-side session storage required, enables horizontal scaling
- **Standards-based**: JWT is industry standard with broad ecosystem support
- **User isolation**: user_id claim in token payload enables efficient query filtering
- **Security**: httpOnly cookies prevent XSS attacks, bcrypt password hashing prevents rainbow table attacks
- **Integration**: Better Auth provides Next.js-native implementation with minimal configuration

**Alternatives Considered**:
1. **Session-based authentication**: Rejected due to server-side state requirement, complicates scaling
2. **OAuth 2.0 with third-party providers**: Deferred to Phase III per spec (out of scope)
3. **Custom JWT implementation**: Rejected due to security risk and reinventing tested library

**Trade-offs**:
- **Chosen approach**: Stateless, scalable, but tokens cannot be revoked until expiration
- **Mitigation**: 24-hour token expiration limits exposure window; token refresh strategy for Phase III

### 2. Database Architecture

**Decision**: Neon Serverless PostgreSQL with SQLModel ORM and async operations

**Rationale**:
- **Relational model**: User-Task relationship maps naturally to foreign key constraints
- **ACID guarantees**: Ensures data consistency for concurrent user operations
- **Type safety**: SQLModel combines SQLAlchemy with Pydantic for compile-time validation
- **Async performance**: Non-blocking database operations improve throughput under load
- **Managed service**: Neon handles connection pooling, backups, scaling automatically

**Alternatives Considered**:
1. **MongoDB/NoSQL**: Rejected because relational data model (user->tasks) fits SQL better
2. **SQLite**: Rejected due to limited concurrent write support, not suitable for multi-user web app
3. **Supabase**: Rejected because built-in auth conflicts with Better Auth choice

**Trade-offs**:
- **Chosen approach**: ACID guarantees and type safety, but requires schema migrations for changes
- **Mitigation**: SQLModel.metadata.create_all() for initial setup; Alembic migrations planned for Phase III

**Schema Design** (see data-model.md for full specification):
```python
User (table)
  id: int (PK, auto-increment)
  email: str (unique, indexed)
  password_hash: str
  created_at: datetime (default: utcnow)

  Relationships:
    tasks: List[Task] (one-to-many)

Task (table)
  id: int (PK, auto-increment)
  title: str (max: 200 chars, required)
  description: str (max: 2000 chars, optional)
  completed: bool (default: False)
  user_id: int (FK -> User.id, indexed)
  created_at: datetime (default: utcnow)
  updated_at: datetime (default: utcnow, updated on modification)

  Relationships:
    owner: User (many-to-one)
```

### 3. API Design Pattern

**Decision**: RESTful API with resource-based endpoints and standard HTTP methods

**Rationale**:
- **Industry standard**: Widely understood, extensive tooling support
- **Predictable**: HTTP methods map directly to CRUD operations
- **Stateless**: Each request contains all necessary context (JWT token)
- **Cacheable**: GET requests can leverage HTTP caching mechanisms
- **Self-documenting**: FastAPI auto-generates OpenAPI documentation

**Endpoint Structure** (see contracts/ for full OpenAPI specs):
```
Authentication:
  POST   /api/auth/signup       → Create user account
  POST   /api/auth/login        → Authenticate user, return JWT

Task Management:
  GET    /api/tasks             → List authenticated user's tasks
  POST   /api/tasks             → Create new task for authenticated user
  GET    /api/tasks/{id}        → Get task details (if owned by user)
  PUT    /api/tasks/{id}        → Update task (if owned by user)
  PATCH  /api/tasks/{id}/complete → Toggle completion status
  DELETE /api/tasks/{id}        → Delete task (if owned by user)
```

**Alternatives Considered**:
1. **GraphQL**: Rejected as overkill for simple CRUD operations, adds complexity
2. **tRPC**: Rejected because tight coupling between frontend/backend limits flexibility
3. **User-scoped URLs** (`/api/{user_id}/tasks`): Rejected because JWT already provides user context, redundant in URL

**Trade-offs**:
- **Chosen approach**: Simple, standard, but requires multiple requests for related data
- **Future enhancement**: Add pagination, filtering via query params when needed (Phase III)

### 4. Frontend Architecture

**Decision**: Next.js 16+ App Router with React Server Components and Client Components

**Rationale**:
- **Server Components**: Reduce JavaScript bundle size, improve initial page load
- **App Router**: File-based routing reduces boilerplate, built-in layouts
- **Type safety**: TypeScript integration catches errors at compile time
- **Developer experience**: Fast Refresh, automatic code splitting, optimized builds
- **SEO-friendly**: Server-side rendering for public pages (login/signup)

**Component Organization**:
```
Server Components (default):
  - Layout components (app/layout.tsx)
  - Static pages (login/signup initial render)

Client Components (use "use client"):
  - TaskForm (interactive form with state)
  - TaskCard (toggle completion, delete actions)
  - API client (fetch with JWT token)
```

**State Management**:
- **Local state**: React useState for form inputs, loading states
- **Server state**: SWR or React Query deferred to Phase III
- **Auth state**: Better Auth context provider manages JWT token

**Alternatives Considered**:
1. **Vite + React Router**: Rejected due to more manual setup, less integrated experience
2. **Remix**: Rejected due to less ecosystem maturity, Next.js has broader adoption
3. **Pages Router**: Rejected because App Router is modern approach with better performance

**Trade-offs**:
- **Chosen approach**: Modern, performant, but requires understanding Server/Client component boundary
- **Mitigation**: Follow Next.js best practices, default to Server Components

### 5. Styling Strategy

**Decision**: Tailwind CSS utility-first framework

**Rationale**:
- **Responsive design**: Built-in breakpoints (sm, md, lg, xl) for mobile-first development
- **Development speed**: Utility classes eliminate context switching between files
- **Consistency**: Design system constraints prevent arbitrary styling
- **Performance**: Unused styles purged in production build
- **Next.js integration**: Zero-config setup with create-next-app

**Responsive Strategy**:
```css
Mobile-first breakpoints:
  Default: 320px-639px (mobile portrait)
  sm: 640px+ (mobile landscape)
  md: 768px+ (tablet)
  lg: 1024px+ (desktop)
  xl: 1280px+ (large desktop)
```

**Alternatives Considered**:
1. **CSS Modules**: Rejected due to more manual work, less systematic approach
2. **Styled Components**: Rejected due to runtime performance cost
3. **Bootstrap**: Rejected due to opinionated component library, larger bundle size

**Trade-offs**:
- **Chosen approach**: Fast development, small bundle, but HTML becomes verbose with many classes
- **Mitigation**: Extract repeated patterns into React components

### 6. Error Handling Strategy

**Decision**: Comprehensive error handling with user-friendly messages and proper HTTP status codes

**Backend Error Handling**:
```python
try:
    # Database operation
except IntegrityError:
    raise HTTPException(status_code=400, detail="Email already registered")
except SQLAlchemyError:
    raise HTTPException(status_code=500, detail="Database error occurred")
```

**Frontend Error Handling**:
```typescript
try {
    const response = await fetch('/api/tasks', { headers: { Authorization: `Bearer ${token}` }})
    if (response.status === 401) {
        router.push('/login')  // Token expired
    }
    if (!response.ok) {
        throw new Error(await response.json().error)
    }
} catch (error) {
    toast.error(error.message)  // User-friendly notification
}
```

**HTTP Status Code Standards**:
- **200 OK**: Successful GET/PUT/PATCH
- **201 Created**: Successful POST
- **400 Bad Request**: Validation error (e.g., empty title)
- **401 Unauthorized**: Missing or invalid JWT token
- **404 Not Found**: Resource doesn't exist or not owned by user
- **500 Internal Server Error**: Unexpected server error

**Rationale**:
- Improves user experience with clear feedback
- Prevents security information leakage (no stack traces)
- Enables debugging without exposing internals
- Follows HTTP standard conventions

### 7. Development Workflow

**Decision**: Concurrent development with hot reload for both frontend and backend

**Backend Development**:
```bash
cd /path/to/project
uvicorn backend.main:app --reload --port 8000
```

**Frontend Development**:
```bash
cd /path/to/project/frontend
npm run dev  # Runs on port 3000
```

**Environment Setup**:
```bash
# .env file (repository root)
DATABASE_URL=postgresql+asyncpg://user:pass@host/db
BETTER_AUTH_SECRET=your-secret-key-min-32-chars
NEXT_PUBLIC_API_URL=http://localhost:8000
```

**Rationale**:
- FastAPI auto-reload detects Python file changes instantly
- Next.js Fast Refresh updates UI without full page reload
- Separate processes enable independent debugging
- CORS configured to allow localhost:3000 -> localhost:8000 requests

## Risk Analysis

### Risk 1: JWT Token Expiration During Active Session

**Probability**: Medium | **Impact**: Medium | **Mitigation**: Implemented

**Description**: User's JWT token expires after 24 hours, causing 401 errors during active session

**Mitigation Strategy**:
- Frontend detects 401 responses and redirects to login page
- Display user-friendly message: "Your session has expired. Please log in again."
- Future enhancement: Implement token refresh mechanism (Phase III)

### Risk 2: Database Connection Failures

**Probability**: Low | **Impact**: High | **Mitigation**: Partial

**Description**: Neon PostgreSQL connection loss causes API failures

**Mitigation Strategy**:
- Backend returns 503 Service Unavailable for database errors
- Frontend displays error message with retry button
- Connection pooling handles transient connection issues
- Future enhancement: Implement retry logic with exponential backoff (Phase III)

### Risk 3: Concurrent Task Updates

**Probability**: Low | **Impact**: Low | **Mitigation**: Accepted

**Description**: Two clients simultaneously update same task, last write wins

**Mitigation Strategy**:
- Accept optimistic concurrency for Phase II (last write wins)
- updated_at timestamp provides audit trail
- Future enhancement: Implement version-based conflict detection (Phase III+)

### Risk 4: Inadequate Input Validation

**Probability**: Medium | **Impact**: Medium | **Mitigation**: Implemented

**Description**: Malicious or malformed input causes server errors or security vulnerabilities

**Mitigation Strategy**:
- Backend: Pydantic schemas validate all request payloads
- Frontend: Form validation before API calls
- Database: SQLModel enforces max length constraints
- SQL injection prevented by SQLModel parameterized queries

### Risk 5: Scalability Under Load

**Probability**: Low (Phase II) | **Impact**: Medium | **Mitigation**: Deferred

**Description**: System degrades with >10 concurrent users or >100 tasks per user

**Mitigation Strategy**:
- Phase II target: 10 concurrent users (specified in assumptions)
- Async database operations improve throughput
- Future enhancement: Pagination for task lists, connection pooling tuning (Phase III)

## Implementation Phases

### Phase 0: Research & Discovery ✅ COMPLETED

**Output**: research.md with resolved technical decisions

**Completed**:
- [x] Next.js 16+ App Router best practices
- [x] FastAPI async patterns and project structure
- [x] SQLModel database model design
- [x] Better Auth JWT integration
- [x] Neon PostgreSQL connection patterns
- [x] Tailwind CSS responsive strategies
- [x] RESTful API conventions
- [x] WSL 2 development environment setup
- [x] Error handling patterns

### Phase 1: Design Artifacts (IN PROGRESS)

**Inputs**: spec.md, research.md, constitution.md

**Outputs**:
1. **data-model.md**: Complete database schema with constraints, relationships, indexes
2. **contracts/auth-api.yaml**: OpenAPI specification for authentication endpoints
3. **contracts/tasks-api.yaml**: OpenAPI specification for task CRUD endpoints
4. **quickstart.md**: Local development setup guide with environment variables, commands

**Tasks**:
- [ ] Generate data-model.md with SQLModel definitions
- [ ] Create OpenAPI contract for authentication endpoints
- [ ] Create OpenAPI contract for task management endpoints
- [ ] Write quickstart guide for local development

**Acceptance Criteria**:
- Data model includes all entities from spec (User, Task)
- API contracts define all functional requirements (FR-001 through FR-036)
- Quickstart enables new developer to run app locally within 15 minutes

### Phase 2: Task Decomposition (PENDING)

**Inputs**: spec.md, plan.md, data-model.md, contracts/

**Output**: tasks.md with atomic, testable tasks

**Process**: Run `/sp.tasks --from plan` to generate dependency-ordered tasks

**Expected Tasks** (preview):
1. Backend database setup (models, migrations, connection)
2. Backend authentication endpoints (signup, login, JWT middleware)
3. Backend task CRUD endpoints (create, read, update, delete, toggle)
4. Frontend authentication pages (signup, login forms)
5. Frontend task management (dashboard, task list, task form, task card)
6. Frontend-backend integration (API client, error handling, loading states)
7. Manual testing validation (all acceptance scenarios from spec)

### Phase 3: Implementation (PENDING)

**Process**: Run `/sp.implement --from tasks` to execute Claude Code implementation

**Not Started**: Awaits task decomposition completion

## Validation & Acceptance

### Pre-Implementation Validation

- [x] Spec approved and complete (no open questions)
- [x] Research resolves all technical uncertainties
- [x] Constitution compliance verified (Phase II requirements)
- [ ] Plan reviewed and approved by stakeholder
- [ ] Data model reviewed for schema correctness
- [ ] API contracts reviewed for completeness

### Post-Implementation Validation

**Functional Validation** (against spec acceptance scenarios):
- [ ] User Story 1: User registration and authentication (4 scenarios)
- [ ] User Story 2: View and manage task list (4 scenarios)
- [ ] User Story 3: Create new tasks (4 scenarios)
- [ ] User Story 4: Update task details (4 scenarios)
- [ ] User Story 5: Toggle task completion status (4 scenarios)
- [ ] User Story 6: Delete tasks (4 scenarios)

**Non-Functional Validation** (against success criteria):
- [ ] SC-001: Account registration completes in <1 minute
- [ ] SC-002: Login and dashboard access in <10 seconds
- [ ] SC-003: Task operations complete in <2 seconds
- [ ] SC-004: 100 tasks displayed without performance degradation
- [ ] SC-005: 100% user data isolation (zero unauthorized access)
- [ ] SC-006: Responsive UI on 320px-1920px screens
- [ ] SC-007: 95%+ appropriate HTTP status codes
- [ ] SC-008: 20+ consecutive sessions without data loss

**Security Validation**:
- [ ] No hardcoded secrets in source code
- [ ] JWT tokens stored in httpOnly cookies
- [ ] Passwords hashed with bcrypt (never plaintext)
- [ ] SQL injection prevented by parameterized queries
- [ ] 401 responses for missing/invalid tokens

## Follow-Up & Future Enhancements

**Phase III Enhancements** (AI-Powered Agents):
- Implement automated test suites (pytest, Jest, Playwright)
- Add token refresh mechanism for long-lived sessions
- Implement task filtering and search functionality
- Add AI-powered task suggestions or categorization

**Phase IV Enhancements** (Container Orchestration):
- Dockerize frontend and backend services
- Create Kubernetes deployment manifests
- Implement health checks and readiness probes

**Phase V Enhancements** (Cloud-Native Architecture):
- Event-driven task notifications
- Multi-cloud deployment strategy
- Distributed tracing and observability

## Architectural Decision Records

No ADRs created for Phase II. Significant decisions documented in this plan:
1. JWT-based authentication (stateless vs session-based)
2. Neon PostgreSQL with SQLModel ORM (relational vs NoSQL)
3. RESTful API design (REST vs GraphQL vs tRPC)
4. Next.js App Router architecture (App Router vs Pages Router)

**ADR Recommendation**: If these decisions prove architecturally significant across multiple phases, consider creating ADRs during Phase III retrospective.

## References

- **Feature Specification**: [specs/002-todo-fullstack-web/spec.md](./spec.md)
- **Research Document**: [specs/002-todo-fullstack-web/research.md](./research.md)
- **Project Constitution**: [.specify/memory/constitution.md](../../.specify/memory/constitution.md)
- **Phase I Specification**: [specs/001-todo-cli-app/spec.md](../001-todo-cli-app/spec.md)

---

**Plan Status**: Phase 1 Design Artifacts In Progress
**Next Action**: Generate data-model.md, contracts/, quickstart.md
**Approval Required**: Yes - stakeholder review before task decomposition

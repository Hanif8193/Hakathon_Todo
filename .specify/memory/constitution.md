<!--
Sync Impact Report:
- Version change: [initial] → 1.0.0
- Added sections: All (initial constitution creation)
- Templates updated (2026-01-13):
  ✅ spec-template.md - Added Constitutional Compliance section with phase applicability
  ✅ plan-template.md - Enhanced Constitution Check with all phase requirements
  ✅ tasks-template.md - Added Constitutional Compliance and verification requirements
  ✅ adr-template.md - Added Constitutional Impact section
  ✅ commands/*.md - No command files exist yet
- Follow-up TODOs: None
-->

# Project Constitution

**Authority Declaration**: This Constitution is the SUPREME GOVERNING DOCUMENT for this project. In all cases of conflict, this Constitution supersedes and overrides:
- All feature specifications
- CLAUDE.md guidance documents
- Source code and implementation
- Infrastructure definitions and configurations
- Any other project documentation

## IMMUTABLE GLOBAL LAWS

These laws apply universally across ALL project phases (Phase I through Phase V) and MUST NOT be violated under any circumstances.

### I. Agentic Implementation Law

**Human developers MUST NOT write manual implementation code.**

- All production implementation code MUST be generated by Claude Code
- Humans write specifications, approve plans, and review outputs only
- Manual coding by humans is permitted ONLY for: specifications, documentation, test scenarios (intent), and configuration templates
- Any human-written code merged to production is a constitutional violation

**Rationale**: Ensures consistency, traceability, and adherence to spec-driven methodology. Prevents undocumented implementation decisions and maintains a single source of truth in specifications.

### II. Spec-Driven Development Law

**All work MUST be specification-driven.**

- Feature specifications MUST be written BEFORE any implementation begins
- Specifications define requirements, constraints, acceptance criteria, and success metrics
- Specs override code: if code contradicts the spec, the spec is authoritative
- No implementation may proceed without an approved specification

**Rationale**: Establishes clear requirements, prevents scope creep, enables proper planning, and ensures all stakeholders align on intent before resources are committed.

### III. Plan-Before-Build Law

**Plans MUST be generated from specs before implementation.**

- Every spec MUST produce an architectural plan
- Plans detail design decisions, alternatives considered, and rationale
- Plans MUST decompose work into atomic, testable tasks
- Implementation proceeds only after plan approval

**Rationale**: Separates business understanding from technical approach, enables architecture review, identifies risks early, and creates traceable decision records.

### IV. Task Decomposition Law

**Work MUST be broken into atomic tasks before implementation.**

- Each task MUST be independently testable
- Tasks MUST include explicit acceptance criteria
- Tasks MUST reference relevant spec sections and plan decisions
- Tasks execute in dependency order

**Rationale**: Enables incremental delivery, parallel work where possible, clear progress tracking, and precise rollback capabilities.

### V. Iterative Review Law

**Review is mandatory at every stage.**

- Specifications reviewed before planning
- Plans reviewed before task generation
- Tasks reviewed before implementation
- Implementation reviewed before merge
- Claude Code solicits human review at checkpoints

**Rationale**: Catches errors early, maintains alignment with intent, prevents rework, and ensures quality gates are enforced.

### VI. Document Hierarchy Law

**Conflict resolution order is strictly defined.**

When documents conflict, authority is resolved in this order:
1. **Constitution** (this document) - supreme authority
2. **Feature Specifications** - business requirements and constraints
3. **CLAUDE.md** - agent operational guidance
4. **Source Code** - implementation artifact

**Rationale**: Establishes unambiguous authority chain, prevents circular dependencies, and ensures governance decisions override implementation convenience.

## PHASE GOVERNANCE

This project evolves through five distinct phases. Each phase introduces new capabilities while preserving all prior constitutional laws.

### Phase I: Command-Line Foundation

**Scope**: CLI application, in-memory data structures, no persistence, no authentication.

**Constitutional Requirements**:
- User interaction via command-line interface only
- Data stored in process memory only
- No external service dependencies
- No user identity or authorization layer
- Focus: business logic and core workflows

**Out of Scope**: Web interfaces, databases, authentication, distributed systems.

### Phase II: Web Application

**Scope**: Web application, persistent database, REST APIs, authentication system.

**Constitutional Requirements**:
- User identity MUST be established via authentication system
- Data MUST persist across sessions in a database
- APIs MUST follow RESTful conventions
- User data MUST be isolated by authenticated identity
- All Phase I business logic MUST remain valid

**Out of Scope**: AI agents, real-time collaboration, container orchestration.

### Phase III: AI-Powered Agents

**Scope**: AI agents, MCP tools, chat interface, stateless services.

**Constitutional Requirements**:
- AI agents MUST NOT access databases directly (see AI & Agent Governance)
- All agent state mutation MUST occur via MCP tools
- Conversation state MUST be persisted
- Services MUST remain stateless
- APIs MUST support agent interaction patterns
- All Phase I-II capabilities MUST remain functional

**Out of Scope**: Container orchestration, cloud-native patterns, event-driven architecture.

### Phase IV: Container Orchestration

**Scope**: Containers (Docker), Kubernetes cluster, Helm charts, local deployment.

**Constitutional Requirements**:
- Containers are execution environments, NOT architectural components
- Business logic MUST NOT depend on Kubernetes APIs or primitives
- Infrastructure MUST be defined declaratively (Helm charts)
- Local cluster deployment MUST be fully functional
- All Phase I-III capabilities MUST operate in containerized environment

**Out of Scope**: Cloud provider services, managed Kubernetes, event streaming platforms.

### Phase V: Cloud-Native Architecture

**Scope**: Event-driven architecture, Kafka messaging, Dapr runtime, cloud deployment.

**Constitutional Requirements**:
- Business logic MUST remain cloud-provider-agnostic
- Event schemas MUST be versioned and backward-compatible
- Services communicate via events or Dapr APIs
- Deployment MUST support multiple cloud providers without code changes
- All Phase I-IV capabilities MUST function in cloud-native mode

**Out of Scope**: This is the final architectural phase; future amendments may extend but not replace.

## SECURITY & IDENTITY LAWS

These laws apply as soon as authentication is introduced (Phase II+) and govern all subsequent phases.

### Authentication & Identity

**User identity MUST come from an authentication system.**

- No hardcoded users, passwords, or API keys in source code
- Identity providers MUST be configurable (not baked into business logic)
- Stateless authentication (e.g., JWT) is strongly preferred over session state
- Authentication layer MUST be replaceable without modifying business logic

### Data Isolation

**User data isolation is mandatory.**

- Every data operation MUST be scoped to an authenticated user context
- No global or shared data pools accessible across users without explicit authorization
- Database queries MUST include user identity filters
- APIs MUST validate user authorization before returning data

### Secrets Management

**Secrets MUST NOT be hardcoded.**

- All secrets, tokens, API keys, and credentials MUST be externalized
- Use environment variables, secret management systems, or configuration vaults
- Secrets MUST NOT appear in version control, logs, or error messages
- Rotation of secrets MUST NOT require code changes

**Rationale**: Prevents security breaches, enables multi-tenancy, supports audit requirements, and maintains trust in the system.

## AI & AGENT GOVERNANCE

These laws apply starting in Phase III and govern all AI agent behavior.

### Agent Data Access

**AI agents MUST NOT access databases directly.**

- Agents operate through well-defined APIs and MCP tools only
- Direct database connections by agents are a constitutional violation
- All data retrieval and mutation flows through service layer
- Agents are stateless consumers of services

**Rationale**: Prevents data corruption, ensures authorization checks, maintains audit trails, and decouples agent logic from data schemas.

### State Mutation via MCP Tools

**All agent-initiated state changes MUST occur via MCP tools.**

- MCP tools encapsulate business logic and authorization
- Tools define clear input/output contracts
- Tools are testable independently of agent logic
- Agent actions are traceable through tool invocations

**Rationale**: Provides a stable interface for agents, enables tool versioning, simplifies testing, and creates an audit trail of agent actions.

### Conversation Persistence

**Agent conversation state MUST be persisted.**

- Conversations are resumable across sessions
- Conversation history is scoped to authenticated users
- Conversation data respects user data isolation laws
- Conversation context includes metadata for debugging and audit

**Rationale**: Enables multi-session interactions, supports user experience continuity, and provides observability into agent behavior.

### Service Statelessness

**Services MUST remain stateless.**

- No in-memory session state in service processes
- All state externalized to databases or caches
- Horizontal scaling MUST NOT break functionality
- Agent requests MUST be independently processable

**Rationale**: Enables elastic scaling, simplifies deployment, improves fault tolerance, and supports distributed architectures.

## INFRASTRUCTURE NEUTRALITY

These laws ensure portability and prevent vendor lock-in across all phases.

### Business Logic Independence

**Business logic MUST NOT depend on deployment environment.**

- No direct dependencies on Kubernetes APIs, cloud provider SDKs, or platform-specific primitives
- Infrastructure concerns handled via abstraction layers (e.g., Dapr)
- Business logic testable outside container/cloud environments
- Platform-specific code isolated in infrastructure layer

**Rationale**: Preserves portability, reduces testing complexity, prevents vendor lock-in, and enables multi-cloud strategies.

### Execution Platform Abstraction

**Containers and Kubernetes are execution platforms, NOT architectural components.**

- Do not design around Kubernetes primitives (pods, services, operators)
- Orchestration is an operational concern, not a design constraint
- Applications MUST run in local, container, and cloud environments
- Infrastructure changes MUST NOT require application code changes

**Rationale**: Decouples architecture from infrastructure, enables local development, reduces operational complexity, and future-proofs the system.

### Cloud Provider Agnosticism

**Cloud provider lock-in MUST be avoided.**

- Use open standards and protocols (HTTP, gRPC, Kafka, NATS, etc.)
- Abstract cloud-specific services behind interfaces
- Deployment artifacts MUST work across AWS, Azure, GCP, or on-premises
- Multi-cloud support is a design goal, not an afterthought

**Rationale**: Maintains negotiating leverage, reduces risk of vendor dependency, enables cost optimization, and supports diverse deployment scenarios.

## DEVELOPMENT WORKFLOW

These laws define the operational process for all phases.

### Specification-First

**Every feature begins with a specification.**

- Specs live in `specs/<feature>/spec.md`
- Specs include: business context, requirements, constraints, acceptance criteria, success metrics
- Specs are versioned and reviewed before implementation begins
- Rejected specs do not proceed to planning

### Plan Generation

**Approved specs generate architectural plans.**

- Plans live in `specs/<feature>/plan.md`
- Plans document: design decisions, alternatives considered, rationale, trade-offs, risks
- Plans reference relevant ADRs (Architecture Decision Records)
- Plans are reviewed for technical feasibility and alignment with constitution

### Task Decomposition

**Plans decompose into actionable tasks.**

- Tasks live in `specs/<feature>/tasks.md`
- Each task is atomic, testable, and independently deliverable
- Tasks include acceptance criteria and test scenarios
- Tasks execute in dependency-respecting order

### Implementation by Claude Code

**Claude Code generates all implementation.**

- Claude Code reads spec, plan, and tasks
- Claude Code produces code, tests, and documentation
- Claude Code executes tests and validates acceptance criteria
- Human review approves or requests revisions

### Iterative Refinement

**Feedback loops are continuous.**

- After each task: review output, validate tests, confirm acceptance criteria
- After each feature: retrospective on spec accuracy and plan effectiveness
- Constitution amendments occur between phases based on lessons learned

## AMENDMENT RULES

This Constitution is a living document but changes are governed strictly.

### Amendment Timing

**Constitution may ONLY be amended between phases.**

- No mid-phase amendments except for critical security or legal issues
- Amendments proposed during phase retrospectives
- Amendments reviewed and approved before next phase begins
- Emergency amendments require documented justification and rollback plan

### Amendment Process

**All amendments MUST include:**

1. **Justification**: Why is the amendment necessary? What problem does it solve?
2. **Impact Analysis**: What existing specs, plans, or code are affected?
3. **Migration Plan**: How will affected artifacts be updated?
4. **Changelog Entry**: Semantic version bump with detailed description
5. **Approval**: Explicit sign-off from project stakeholders

### Version Semantics

**Constitution versioning follows semantic versioning:**

- **MAJOR**: Backward-incompatible governance changes (removed principles, redefined laws)
- **MINOR**: New principles, sections, or materially expanded guidance
- **PATCH**: Clarifications, wording improvements, typo fixes, non-semantic refinements

**Current Version**: 1.0.0 (initial ratification)

### Propagation Requirements

**Amendments MUST propagate to dependent artifacts:**

- Update `.specify/templates/plan-template.md` if governance affects planning
- Update `.specify/templates/spec-template.md` if requirements structure changes
- Update `.specify/templates/tasks-template.md` if task categorization changes
- Update `CLAUDE.md` if agent operational guidance changes
- Document propagation in Sync Impact Report at top of constitution file

## COMPLIANCE & ENFORCEMENT

### Compliance Verification

**All deliverables MUST verify constitutional compliance:**

- Specifications MUST reference applicable constitutional principles
- Plans MUST document alignment with phase governance and architectural laws
- Tasks MUST include constitutional compliance as acceptance criteria
- Code reviews MUST validate adherence to all applicable laws

### Violation Handling

**Constitutional violations MUST be addressed immediately:**

- Violations block merge/deployment until resolved
- Repeated violations trigger process review and possible amendment
- No "technical debt" exceptions for constitutional requirements
- Violations documented in retrospectives for pattern analysis

### Audit Trail

**All governance decisions MUST be traceable:**

- Specifications link to relevant constitutional sections
- Plans document alternatives considered and rationale
- ADRs capture architecturally significant decisions
- PHRs (Prompt History Records) capture all agent interactions
- Retrospectives evaluate constitutional effectiveness

---

**Version**: 1.0.0 | **Ratified**: 2026-01-13 | **Last Amended**: 2026-01-13
